<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>李二狗的C++备考笔记 | Binarydog_Lee&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="BinaryDog Lee’s Note of C++ 作者数媒李二狗。（P.S.能不能star一下…）  catalogue1.函数默认值和函数重载 2. 应用new&#x2F;delete运算符实现深复制 3. 引用传递参数 4. 对象构造&#x2F;析构的顺序 5. 基类派生类各种形态的赋值兼容、虚函数的静态、动态关联 6. 格式化I&#x2F;O的常用格式标志位、成员函数和流操纵算子 7. 函数模板（结合数组的基本算法">
<meta property="og:type" content="article">
<meta property="og:title" content="李二狗的C++备考笔记">
<meta property="og:url" content="https://nszjjj.github.io/2021/12/20/NoteofCpp/index.html">
<meta property="og:site_name" content="Binarydog_Lee&#39;s Blog">
<meta property="og:description" content="BinaryDog Lee’s Note of C++ 作者数媒李二狗。（P.S.能不能star一下…）  catalogue1.函数默认值和函数重载 2. 应用new&#x2F;delete运算符实现深复制 3. 引用传递参数 4. 对象构造&#x2F;析构的顺序 5. 基类派生类各种形态的赋值兼容、虚函数的静态、动态关联 6. 格式化I&#x2F;O的常用格式标志位、成员函数和流操纵算子 7. 函数模板（结合数组的基本算法">
<meta property="og:locale">
<meta property="article:published_time" content="2021-12-20T13:08:04.000Z">
<meta property="article:modified_time" content="2021-12-20T14:17:36.474Z">
<meta property="article:author" content="nszjjj">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Binarydog_Lee&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Binarydog_Lee&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://nszjjj.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-NoteofCpp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/12/20/NoteofCpp/" class="article-date">
  <time datetime="2021-12-20T13:08:04.000Z" itemprop="datePublished">2021-12-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      李二狗的C++备考笔记
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="BinaryDog-Lee’s-Note-of-C"><a href="#BinaryDog-Lee’s-Note-of-C" class="headerlink" title="BinaryDog Lee’s Note of C++"></a>BinaryDog Lee’s Note of C++</h1><blockquote>
<p>作者数媒李二狗。（P.S.能不能star一下…）</p>
</blockquote>
<h2 id="catalogue"><a href="#catalogue" class="headerlink" title="catalogue"></a>catalogue</h2><p><a href="#1">1.函数默认值和函数重载</a></p>
<p><a href="#2">2. 应用new/delete运算符实现深复制</a></p>
<p><a href="#3">3. 引用传递参数</a></p>
<p><a href="#4">4. 对象构造/析构的顺序</a></p>
<p><a href="#5">5. 基类派生类各种形态的赋值兼容、虚函数的静态、动态关联</a></p>
<p><a href="#6">6. 格式化I/O的常用格式标志位、成员函数和流操纵算子</a></p>
<p><a href="#7">7. 函数模板（结合数组的基本算法）</a></p>
<p><a href="#8">8. 构造函数/默认构造函数的定义、常用运算符函数的重载及应用、对象数组</a></p>
<p><a href="#9">9. string、vector等基本容器类结合find、erase等基本算法的应用</a></p>
<p><a href="#10">10. 类及常用成员函数的定义，类的复合关系的应用</a></p>
<p><a href="#11">11. 多态性的应用，要求用类图分析类及继承关系，要求抽象基类、动态多态性</a></p>
<p><a href="#12">12. 个人见到的一些琐碎知识点</a></p>
<h2 id="detail"><a href="#detail" class="headerlink" title="detail"></a>detail</h2><blockquote>
<p>以下代码均在devcpp的TDM-GCC4.8.1 64-bit Debug下运行成功</p>
</blockquote>
<h2 id="1">1.函数默认值和函数重载</h2>


<h3 id="1-1函数默认值"><a href="#1-1函数默认值" class="headerlink" title="1.1函数默认值"></a>1.1函数默认值</h3><blockquote>
<p>部分样例取自cppreference，下文不再标注</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数名：“isodd”</span></span><br><span class="line"><span class="comment">// 形参列表拥有一个形参，具有名字 “n” 和类型 int</span></span><br><span class="line"><span class="comment">// 返回类型是 bool</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isodd</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;                      <span class="comment">// 函数体开始</span></span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">2</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>通俗地讲，形参就是在这个函数体内，管这个传入的参数叫什么</p>
<p>而实参就是调用这个函数时，传入的参数它本身的名字</p>
<p>比如说在某处有程序段如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">bool</span> b = <span class="built_in">isodd</span>(a);</span><br></pre></td></tr></table></figure>
<p>这里a这个传入的参数就是<b>实参（argument）</b>，结合上面的函数定义知形参是n</p>
<p>这种传递参数方式叫做<b>值传递</b>，只是把参数的值传递了过去，内存中形参n的地址和实参a的地址是<b>不一样的</b></p>
<p>函数的默认值写在函数<b>形参列表</b>中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a = <span class="number">0</span>,<span class="keyword">int</span> b = <span class="number">1</span>,<span class="keyword">int</span> c = <span class="number">7</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a+b+c;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">sum</span>(<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>)&lt;&lt;endl;<span class="comment">//输出9，相当于5+3+1</span></span><br><span class="line">	cout&lt;&lt;<span class="built_in">sum</span>(<span class="number">5</span>,<span class="number">3</span>)&lt;&lt;endl;<span class="comment">//输出15，相当于5+3+7</span></span><br><span class="line">	cout&lt;&lt;<span class="built_in">sum</span>(<span class="number">5</span>)&lt;&lt;endl;<span class="comment">//输出13，相当于5+1+7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码sum后面的形参列表看起来像是赋值的地方就是指定默认值</p>
<p>不可能存在参数列表中多个参数里，前面的参数没有使用默认值而后面参数没有使用默认值的情况，例如sum(5)的5就是传给了a而非后面的参数</p>
<h3 id="1-2函数重载"><a href="#1-2函数重载" class="headerlink" title="1.2函数重载"></a>1.2函数重载</h3><blockquote>
<p>同一作用域中，可以有多个函数拥有相同的名称，只要其形参列表，以及对于非静态成员函数的 cv 或引用 (C++11 起)限定不同即可。这被称作函数重载</p>
</blockquote>
<p>通俗的说就是重载函数的参数个数，参数类型或参数顺序三者中必须有一个不同</p>
<p>再通俗点说就是函数原型不能一样</p>
<p>注：同名函数只有参数表不同才能算重载。两个同名函数的参数表相同而返回值类型不同不是重载，而是重复定义，是不允许的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a+b+c;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a+b;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">sum</span>(<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">sum</span>(<span class="number">5</span>,<span class="number">3</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上图两个sum函数原型分别是int sum(int,int,int)和int sum(int,int)</p>
<p>直观上的感受就是两个名字一样的函数，功能却不相同</p>
<h2 id="2">2. 应用new/delete运算符实现深复制</h2>

<h3 id="2-1深复制和浅复制"><a href="#2-1深复制和浅复制" class="headerlink" title="2.1深复制和浅复制"></a>2.1深复制和浅复制</h3><blockquote>
<p>深拷贝和浅拷贝最根本的区别在于是否真正获取一个对象的复制实体，而不是引用。或者说是数据是否在同一块内存区域的区别。</p>
</blockquote>
<p>深复制和浅复制一般说的是面向对象中的类对象，而非诸如int、double等普通的变量。</p>
<p>浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。</p>
<p>深复制：在计算机中开辟一块<b>新的内存地址</b>用于存放复制的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">char</span>* str;</span><br><span class="line">		<span class="built_in">test</span>(<span class="keyword">char</span>* a)&#123;</span><br><span class="line">			<span class="comment">//str=new char[strlen(a)+1];</span></span><br><span class="line">			<span class="built_in">strcpy</span>(str,a);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">			cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">test <span class="title">var_1</span><span class="params">(<span class="string">&quot;assss&quot;</span>)</span></span>;</span><br><span class="line">	var_1.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例中注释行为本程序关键部分，如果注释掉本语句，则程序出现问题，原因在于char*指针<b>并未初始化</b>，它指向的值是随机的，并不能确保这个指向的位置就是可用的内存区域。</p>
<p>去掉注释后程序可正常运行，原因在于为var_1这个变量开辟了传入参数a大小的内存空间并让指针指向它，strlen获取的是字符串的长度，不包括结尾的\0，但是结尾的\0也要储存，所以还得在strlen(a)基础上＋1。</p>
<p>深复制的关键是，要正确地为指针变量开辟空间，并且在析构时<b>释放且只释放一次</b>，如果两个对象中各自的指针由于浅复制指向的是同一片内存区域，那析构时释放两次空间会出现问题。</p>
<h2 id="3">3. 引用传递参数</h2>

<p>上文提到了<b>值传递</b>，事实上参数的传递有值传递、地址传递和引用传递三种传参方式。</p>
<p>引用类似于指针，使用符号&amp;，这里的&amp;作用和取地址符&amp;不一样。</p>
<blockquote>
<p>引用的基本语法是：<b>数据类型 &amp;别名 = 原名</b></p>
</blockquote>
<p>引用可以作为函数返回值，例如int&amp; f(){…}就可以返回一个int的引用，但请注意<b>不要返回该函数局部变量的引用</b>，因为在返回之后就因为生命周期到了而被销毁了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapp</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">	<span class="comment">//cout&lt;&lt;&quot;地址：&quot;&lt;&lt;&amp;a&lt;&lt;&quot; &quot;&lt;&lt;&amp;b&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> c = <span class="number">2</span>,d = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">swap</span>(c,d);</span><br><span class="line">	cout&lt;&lt;c&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;d&lt;&lt;endl;<span class="comment">//输出2 3</span></span><br><span class="line">	<span class="built_in">swapp</span>(c,d);</span><br><span class="line">	cout&lt;&lt;c&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;d&lt;&lt;endl;<span class="comment">//输出3 2</span></span><br><span class="line">	<span class="comment">//cout&lt;&lt;&quot;地址：&quot;&lt;&lt;&amp;c&lt;&lt;&quot; &quot;&lt;&lt;&amp;d&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上程序，如果把cout的注释行加上，可以看到函数swapp的形参a和b在内存中的地址和实参c与d在内存中的地址是一样的。它们可以在一定程度上相当于一个值的两个名字。</p>
<h2 id="4">4. 对象构造/析构的顺序</h2>

<h3 id="4-1构造函数"><a href="#4-1构造函数" class="headerlink" title="4.1构造函数"></a>4.1构造函数</h3><blockquote>
<p>构造函数是类的一种特殊的<b>非静态成员函数</b>，用于初始化该类型的对象</p>
</blockquote>
<ol>
<li>如果自己不写，则会有一个默认的构造函数。如果写了则替代。</li>
<li>任何构造函数可以在函数定义的花括号前包含成员初始化器列表（见后文）</li>
<li>构造函数没有名字且无法<b>被</b>调用</li>
<li>基本的语法是 类名();</li>
<li>构造函数不可以是虚函数</li>
</ol>
<h3 id="4-2析构函数"><a href="#4-2析构函数" class="headerlink" title="4.2析构函数"></a>4.2析构函数</h3><blockquote>
<p>析构函数是对象生存期终结时调用的特殊成员函数。析构函数的目的是释放对象<b>可能在其生存期间获得的资源</b></p>
</blockquote>
<ol>
<li>基本的语法是~类名();</li>
<li>如果不向类提供用户提供的析构函数，编译器总是会生成一个析构函数</li>
<li>析构函数可以是<b>纯虚</b>的，并且常常是虚函数。</li>
</ol>
<p>调用析构函数的时间点包括：</p>
<ul>
<li>程序终止时，为静态储存期的对象析构</li>
<li>退出线程时，线程局部储存的对象</li>
<li>作用域结束</li>
<li>delete表达式</li>
<li>完整表达式结尾，对于无名变量</li>
<li>栈回溯</li>
</ul>
<h3 id="4-3顺序问题"><a href="#4-3顺序问题" class="headerlink" title="4.3顺序问题"></a>4.3顺序问题</h3><blockquote>
<p>多数情况下是：先构造，后析构，后构造，先析构，类似于栈先进后出的原则。</p>
</blockquote>
<p>派生类的构造：先执行基类的构造函数，再执行派生类的构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Abase</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">int</span> data_1,data_2; </span><br><span class="line">		<span class="built_in">Abase</span>(<span class="keyword">int</span> a = <span class="number">4</span>,<span class="keyword">int</span> b = <span class="number">3</span>):<span class="built_in">data_1</span>(a),<span class="built_in">data_2</span>(b)&#123;</span><br><span class="line">			<span class="comment">//data(a)是一个成员初始化器 </span></span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;base class constructed&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">virtual</span> ~<span class="built_in">Abase</span>()&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;base class deconstructed&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aclass</span>:</span><span class="keyword">public</span> Abase&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Aclass</span>()&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;class constructed&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		~<span class="built_in">Aclass</span>()&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;class deconstructed&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	Aclass* a = <span class="keyword">new</span> <span class="built_in">Aclass</span>();</span><br><span class="line">	<span class="keyword">delete</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出是：</p>
<blockquote>
<p>base class constructed<br>class constructed<br>class deconstructed<br>base class deconstructed</p>
</blockquote>
<h2 id="5">5. 基类派生类各种形态的赋值兼容、虚函数的静态、动态关联</h2>

<h3 id="5-1-赋值兼容"><a href="#5-1-赋值兼容" class="headerlink" title="5.1 赋值兼容"></a>5.1 赋值兼容</h3><blockquote>
<p>提示：派生类如果没有指明继承方式，则<b>默认继承方式（缺省继承方式）为private</b>，而结构体默认继承是public。</p>
</blockquote>
<blockquote>
<p>使用private继承，父类的protected和public属性在子类中变为private<br>使用protected继承，父类的protected和public属性在子类中变为protected<br>使用public继承，父类中的protected和public属性不发生改变</p>
</blockquote>
<ul>
<li>派生类对象可以赋值给基类对象</li>
<li>派生类对象可以初始化基类的引用</li>
<li>派生类对象的地址可以赋值给指向基类的指针</li>
</ul>
<p>替代之后派生类对象就可以作为基类对象使用并且只能使用从基类继承的成员</p>
<p>将上一节的程序改动后的示例程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Abase</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">int</span> data_1,data_2; </span><br><span class="line">		<span class="built_in">Abase</span>(<span class="keyword">int</span> a = <span class="number">4</span>,<span class="keyword">int</span> b = <span class="number">3</span>):<span class="built_in">data_1</span>(a),<span class="built_in">data_2</span>(b)&#123;</span><br><span class="line">			<span class="comment">//data(a)是一个成员初始化器 </span></span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;base class constructed&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">virtual</span> ~<span class="built_in">Abase</span>()&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;base class deconstructed&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aclass</span>:</span><span class="keyword">public</span> Abase&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Aclass</span>()&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;class constructed&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		~<span class="built_in">Aclass</span>()&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;class deconstructed&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	Abase* a = <span class="keyword">new</span> <span class="built_in">Aclass</span>();</span><br><span class="line">	<span class="comment">//由Aclass改为Abase依然可以使用 </span></span><br><span class="line">	<span class="keyword">delete</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这体现了<b>派生类对象的地址可以赋值给指向基类的指针</b>这一点</p>
<h3 id="5-2虚函数的静态关联"><a href="#5-2虚函数的静态关联" class="headerlink" title="5.2虚函数的静态关联"></a>5.2虚函数的静态关联</h3><p>派生类中的数据储存区域总有一块和基类相似，这就是<b>静态关联</b>，它是上文讲到的派生类对象的地址可以赋值给指向基类的指针的基础。</p>
<p>当把派生类对象的地址赋值给基类指针时，会自动进行指针类型转换，将派生类对象的地址转换为基类指针，然后基类指针<b>只指向其中的基类部分</b>，这就解释了上文“替代之后派生类对象就可以作为基类对象使用并且只能使用从基类继承的成员”这句话。</p>
<h3 id="5-3动态关联的前置内容"><a href="#5-3动态关联的前置内容" class="headerlink" title="5.3动态关联的前置内容"></a>5.3动态关联的前置内容</h3><p>动态关联之前需要了解<b>同名覆盖</b></p>
<p>同名覆盖就是一种函数重载，在基类和派生类中同名同类型同参数的一个函数，派生类的会代替基类的，也就是说<b>不能使用这个函数名来来调用基类的函数</b>，因为该同名函数指向的是派生类中的定义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;class a&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125; </span><br><span class="line">&#125; ;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;class b&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125; </span><br><span class="line">&#125; ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	A a;</span><br><span class="line">	B b;</span><br><span class="line">	a.<span class="built_in">f</span>();<span class="comment">//输出class a</span></span><br><span class="line">	b.<span class="built_in">f</span>();<span class="comment">//输出class b</span></span><br><span class="line">	b.A::<span class="built_in">f</span>();<span class="comment">//输出class a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若要调用基类的则需加上作用域运算符，在上例中是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.A::<span class="built_in">f</span>();</span><br></pre></td></tr></table></figure>
<h3 id="5-4-通过虚函数实现动态关联"><a href="#5-4-通过虚函数实现动态关联" class="headerlink" title="5.4 通过虚函数实现动态关联"></a>5.4 通过虚函数实现动态关联</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;class a&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125; </span><br><span class="line">&#125; ;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;class b&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125; </span><br><span class="line">&#125; ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	B b;</span><br><span class="line">	A* p = &amp;b;</span><br><span class="line">	A&amp; ab = b;</span><br><span class="line">	p-&gt;<span class="built_in">f</span>();<span class="comment">//输出class a</span></span><br><span class="line">	ab.<span class="built_in">f</span>();<span class="comment">//输出class a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们期望使用一个指针，访问不同类中的同名函数而不受指针类型的限制，这时候就需要虚函数来取消静态关联，来实现函数和对象的动态绑定。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;class a&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125; </span><br><span class="line">&#125; ;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;class b&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	B b;</span><br><span class="line">	A* p = &amp;b;</span><br><span class="line">	A&amp; ab = b;</span><br><span class="line">	p-&gt;<span class="built_in">f</span>();</span><br><span class="line">	ab.<span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上有两个改动</p>
<ol>
<li>为基类的f()添加了virtual关键字修饰</li>
<li>为派生类的f()添加了override关键字修饰，目的是明确该函数是虚函数而不是函数重载</li>
</ol>
<h3 id="5-5-关于动态联编"><a href="#5-5-关于动态联编" class="headerlink" title="5.5 关于动态联编"></a>5.5 关于动态联编</h3><p>动态联编是指联编在程序<b>运行时</b>（注意啊不是编译时，编译时那就是静态联编了）动态地进行，根据当时的情况来确定调用哪个同名函数，实际上是在运行时虚函数的实现。</p>
<p>别名：<b>晚期联编</b>或<b>动态束定</b></p>
<p>直观表现：对成员函数的选择是基于对象的类型，针对不同的对象类型将做出不同的编译结果。</p>
<p>何时使用：涉及到多态性和虚函数时应该使用动态联编。</p>
<p>动态联编要求派生类中的虚函数与基类中对应的虚函数具有相同的名称、相同的参数个数和相同的对应参数类型、返回值</p>
<h2 id="6">6. 格式化I/O的常用格式标志位、成员函数和流操纵算子</h2>

<blockquote>
<p>格式化I/O使用头文件iomanip</p>
</blockquote>
<p>格式化包括：</p>
<ul>
<li>宽度控制</li>
<li>对齐控制</li>
<li>填充控制</li>
<li>精度控制</li>
<li>进制控制</li>
</ul>
<table>
<thead>
<tr>
<th align="left">算子</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">setbase(int base)</td>
<td align="left">以base进制输出整数值</td>
</tr>
<tr>
<td align="left">setprecision(int n)</td>
<td align="left">将浮点数<b>有效数字</b>设置为n位</td>
</tr>
<tr>
<td align="left">setw(int n)</td>
<td align="left">按照n个字符来读或写</td>
</tr>
<tr>
<td align="left">flush</td>
<td align="left">刷新ostream缓冲区</td>
</tr>
<tr>
<td align="left">ends</td>
<td align="left">插入字符串结束符，然后刷新ostream缓冲区</td>
</tr>
<tr>
<td align="left">endl</td>
<td align="left">插入换行符，然后刷新ostream缓冲区</td>
</tr>
<tr>
<td align="left">ws</td>
<td align="left">跳过空白字符</td>
</tr>
<tr>
<td align="left">setfill(int ch）</td>
<td align="left">用ch填充空白字符</td>
</tr>
<tr>
<td align="left">dec</td>
<td align="left">十进制</td>
</tr>
<tr>
<td align="left">oct</td>
<td align="left">八进制</td>
</tr>
<tr>
<td align="left">hex</td>
<td align="left">十六进制</td>
</tr>
<tr>
<td align="left">setiosflags(long lflags)</td>
<td align="left">根据ios类中的枚举设置特定的格式</td>
</tr>
</tbody></table>
<p>ios类的枚举常量以ios::xx形式使用</p>
<table>
<thead>
<tr>
<th align="left">枚举常量</th>
<th align="left">用途</th>
<th align="left">枚举常量</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">skipws</td>
<td align="left">跳过空格</td>
<td align="left">showbase</td>
<td align="left">显示基指示符</td>
</tr>
<tr>
<td align="left">left</td>
<td align="left">左对齐</td>
<td align="left">showpoint</td>
<td align="left">输出小数尾数0</td>
</tr>
<tr>
<td align="left">right</td>
<td align="left">右对齐</td>
<td align="left">uppercase</td>
<td align="left">十六进制大写</td>
</tr>
<tr>
<td align="left">internal</td>
<td align="left">符号左对齐，数值右对齐</td>
<td align="left">showpos</td>
<td align="left">输出正数符号</td>
</tr>
<tr>
<td align="left">dec</td>
<td align="left">十进制</td>
<td align="left">scientific</td>
<td align="left">科学计数法</td>
</tr>
<tr>
<td align="left">oct</td>
<td align="left">八进制</td>
<td align="left">fixed</td>
<td align="left">小数按定点表示</td>
</tr>
<tr>
<td align="left">hex</td>
<td align="left">十六进制</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>示例程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">114514</span>;</span><br><span class="line">	<span class="keyword">double</span> d = <span class="number">114.5141919810</span>;</span><br><span class="line">	cout&lt;&lt;n&lt;&lt;endl&lt;&lt;<span class="built_in">setw</span>(<span class="number">10</span>)&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;d&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">4</span>)&lt;&lt;d&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出：<br>114514<br>↔↔↔↔114514<br>114.514<br>114.5<br>注:使用↔来表示空格，以使结果更加直观清晰</p>
</blockquote>
<p>显然第二行的114514加上前面的空格刚好凑齐设置的域宽10。</p>
<p>注意：setw<b>只作用于紧随其后的部分</b>，例如输出114.514那行并没有被上一行的setw作用到</p>
<h2 id="7">7. 函数模板（结合数组的基本算法）</h2>

<h3 id="7-1函数模板"><a href="#7-1函数模板" class="headerlink" title="7.1函数模板"></a>7.1函数模板</h3><blockquote>
<p>基础用法是template&lt;形参列表&gt; 常规的函数声明</p>
</blockquote>
<p><b>为什么要使用函数模板？</b></p>
<p>一个典型的场景是，我们有一个计算交换函数swap，可以交换两个参数的值。如果我们写作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a,<span class="keyword">int</span>&amp; b)</span></span>;</span><br></pre></td></tr></table></figure>
<p>那这只能交换int类型的变量。但是如果想交换float类型、double类型等变量，就需要写多个函数，看到这里虽然已经掌握了函数重载，但是显然这不是最优的解决方案。</p>
<p>随着需要处理的数据类型的增加，代码会变得庞大而冗余</p>
<p>我们不期望反复写多个相似的函数及其定义，而希望寻求一种高效的解决方案。</p>
<p>所以我们使用函数模板来使代码更加简洁和高效，以及获得更强的重用性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_1</span><span class="params">(T&amp; a,T&amp; b)</span></span>&#123;</span><br><span class="line"><span class="comment">//void swap(int&amp; a,int&amp; b)&#123;</span></span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addup</span><span class="params">(T&amp; a,T&amp; b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a+b;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">9</span>,b = <span class="number">3</span>,c = <span class="number">19</span>;</span><br><span class="line">	<span class="keyword">char</span> f = <span class="string">&#x27;f&#x27;</span>,d = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">	cout&lt;&lt;addup&lt;<span class="keyword">int</span>&gt;(a,b)&lt;&lt;endl;<span class="comment">//12</span></span><br><span class="line">	cout&lt;&lt;addup&lt;<span class="keyword">int</span>&gt;(c,b)&lt;&lt;endl;<span class="comment">//22</span></span><br><span class="line">	<span class="built_in">swap_1</span>(d,f);</span><br><span class="line">	cout&lt;&lt;d&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;f&lt;&lt;endl;<span class="comment">//f d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<b>类成员函数模板不能是虚函数</b>，这与虚函数表有关，因为我们需要再解析一个类之前确定其虚函数表大小，但是模板函数只有实例化之后才能确定大小，进而确定虚函数表的大小。但是虚函数表是在类实例化之前就确定的，这与之冲突</p>
<h3 id="7-2-数组参数的函数模板"><a href="#7-2-数组参数的函数模板" class="headerlink" title="7.2 数组参数的函数模板"></a>7.2 数组参数的函数模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T(&amp;arr))</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="built_in"><span class="keyword">sizeof</span></span>(arr)/<span class="built_in"><span class="keyword">sizeof</span></span>(arr[<span class="number">0</span>]) ;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		cout&lt;&lt;arr[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arraysort</span><span class="params">(T(&amp;arr),<span class="keyword">bool</span> flag)</span></span>&#123;</span><br><span class="line">	<span class="comment">//flag==true时升序排列</span></span><br><span class="line">	<span class="keyword">int</span> n = <span class="built_in"><span class="keyword">sizeof</span></span>(arr)/<span class="built_in"><span class="keyword">sizeof</span></span>(arr[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n<span class="number">-1</span>;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;n-i<span class="number">-1</span>;++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(flag&amp;&amp;(arr[j]&gt;arr[j+<span class="number">1</span>]))&#123;</span><br><span class="line">				<span class="built_in">swap</span>(arr[j],arr[j+<span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(!flag&amp;&amp;(arr[j+<span class="number">1</span>]&gt;arr[j])) &#123;</span><br><span class="line">				<span class="built_in">swap</span>(arr[j],arr[j+<span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">4</span>&#125;;</span><br><span class="line">	<span class="built_in">arraysort</span>(a,<span class="literal">true</span>);<span class="comment">//升序排列</span></span><br><span class="line">	<span class="built_in">print</span>(a);<span class="comment">//输出0 1 2 3 4</span></span><br><span class="line">	<span class="built_in">arraysort</span>(a,<span class="literal">false</span>);<span class="comment">//降序排列</span></span><br><span class="line">	<span class="built_in">print</span>(a);<span class="comment">//输出4 3 2 1 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数模板中传数组一定要传引用，不然类型推导时传数组会退化为指针，无法正确获取数据，甚至求数组大小n都无法求。</p>
<h3 id="7-3-实际运用"><a href="#7-3-实际运用" class="headerlink" title="7.3 实际运用"></a>7.3 实际运用</h3><p>犯懒，把我作业三的代码粘过来了。</p>
<blockquote>
<p>题目：自定义函数模板对有 n 个元素的数组 a 排序，并把排序准则设置成函数参数。 </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ohhhmygod</span><span class="params">(T a,T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//前者 a&gt;后者 b 返回 1 以进行冒泡排序的交换 是递增排序</span></span><br><span class="line"><span class="comment">//要是搞递减就把下面的大于改成小于</span></span><br><span class="line">	<span class="keyword">return</span> a&gt;b?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_sort</span><span class="params">(T *a, <span class="keyword">int</span> n, <span class="keyword">int</span> (*p)(T, T))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//不难 就是模板函数指针 类似 c#的委托</span></span><br><span class="line"><span class="comment">//传参时需要模板实例化一下</span></span><br><span class="line">	<span class="keyword">if</span>(n&lt;<span class="number">2</span>)<span class="keyword">return</span>;</span><br><span class="line">	T temp;</span><br><span class="line">	<span class="keyword">int</span> nn = n; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;(i&lt;nn<span class="number">-1</span>)?<span class="literal">true</span>:(i=<span class="number">0</span>,--nn,(i&lt;nn<span class="number">-1</span>)?<span class="literal">true</span>:<span class="literal">false</span>);++i)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="comment">//冒泡排序，写一个for纯粹是为了好玩</span></span><br><span class="line">		<span class="keyword">if</span>((*p)(a[i],a[i+<span class="number">1</span>]))</span><br><span class="line">		&#123;</span><br><span class="line">			temp = a[i];</span><br><span class="line">			a[i] = a[i+<span class="number">1</span>];</span><br><span class="line">			a[i+<span class="number">1</span>] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">4</span>]=&#123;<span class="number">8</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">9</span>&#125;;</span><br><span class="line">	<span class="keyword">char</span> s[<span class="number">5</span>]=&#123;<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line">	<span class="built_in">my_sort</span>(a,<span class="number">4</span>,ohhhmygod&lt;<span class="keyword">int</span>&gt;);</span><br><span class="line">	<span class="built_in">my_sort</span>(s,<span class="number">5</span>,ohhhmygod&lt;<span class="keyword">char</span>&gt;);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(a)/<span class="built_in"><span class="keyword">sizeof</span></span>(a[<span class="number">0</span>]);++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(s)/<span class="built_in"><span class="keyword">sizeof</span></span>(s[<span class="number">0</span>]);++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;s[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="8">8. 构造函数/默认构造函数的定义、常用运算符函数的重载及应用、对象数组</h2>

<h3 id="8-1构造函数-默认构造函数"><a href="#8-1构造函数-默认构造函数" class="headerlink" title="8.1构造函数/默认构造函数"></a>8.1构造函数/默认构造函数</h3><p>见第四节</p>
<h3 id="8-2-常用运算符重载及应用"><a href="#8-2-常用运算符重载及应用" class="headerlink" title="8.2 常用运算符重载及应用"></a>8.2 常用运算符重载及应用</h3><p>常见运算符重载分为</p>
<ol>
<li>使用外部函数进行运算符重载</li>
<li>使用成员函数进行运算符重载</li>
</ol>
<p>重载的适用运算符：</p>
<ul>
<li>只能作为类成员函数重载的运算符有：() 、[] 、-&gt; 、=</li>
<li>不能被重载的运算符有：. 、.* 、:: 、?: 、sizeof</li>
</ul>
<p>要调用运算符重载函数，有两种方法</p>
<ul>
<li>一种是通过函数名调用，即operator+(t1,t2)</li>
<li>另一种是在使用运算符的时候自动调用</li>
</ul>
<p>对于二元运算符：</p>
<p>如果是非成员函数重载，它是不知道调用者是谁的，因此需要传<b>两个参数</b>，一个是调用者，另一个是参与运算的。</p>
<p>如果作为成员函数重载运算符，是知道调用者是谁的，因此只需要<b>一个参数</b>，即另一个参与运算的数据参数。</p>
<p>对于一元运算符：</p>
<p>（我说的就是自增与自减）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Returntype <span class="keyword">operator</span>++();<span class="comment">//前缀自增</span></span><br><span class="line">Returntype <span class="keyword">operator</span>++(<span class="keyword">int</span>);<span class="comment">//后缀自增</span></span><br><span class="line"><span class="comment">//int在括号是为了向编译器说明这是一个后缀形式，而不是表示整数。</span></span><br><span class="line"><span class="comment">//这个形参是0，但是在函数体中用不到，只是为了区分前置后置而已。</span></span><br></pre></td></tr></table></figure>

<p>注：递增和递减一般是对改变对象的状态，所以一般是重载为成员函数。</p>
<p>以下代码摘录自头歌，为自定义Int类重载函数，其中的运算符重载已经非常值得借鉴了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _INT_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _INT_H_</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Int</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> value;   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Int</span>():<span class="built_in">value</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">Int</span>(Int <span class="keyword">const</span>&amp;rhs):<span class="built_in">value</span>(rhs.value)&#123;&#125;</span><br><span class="line">    <span class="built_in">Int</span>(<span class="keyword">int</span> v):<span class="built_in">value</span>(v)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span><span class="keyword">const</span></span>&#123;<span class="keyword">return</span> value;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;value=v;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (Int <span class="keyword">const</span>&amp;rhs);</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> != (Int <span class="keyword">const</span>&amp;rhs);</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Int <span class="keyword">const</span>&amp;rhs);</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;= (Int <span class="keyword">const</span>&amp;rhs);</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (Int <span class="keyword">const</span>&amp;rhs);</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;= (Int <span class="keyword">const</span>&amp;rhs);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">bool</span> Int::<span class="keyword">operator</span> ==(Int <span class="keyword">const</span>&amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> value == rhs.<span class="built_in">getValue</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> Int::<span class="keyword">operator</span> !=(Int <span class="keyword">const</span>&amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> !(<span class="keyword">operator</span> == (rhs));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> Int::<span class="keyword">operator</span> &lt;(Int <span class="keyword">const</span>&amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> value &lt; rhs.<span class="built_in">getValue</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> Int::<span class="keyword">operator</span> &lt;=(Int <span class="keyword">const</span>&amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">operator</span> &lt; (rhs) || <span class="keyword">operator</span> == (rhs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> Int::<span class="keyword">operator</span> &gt;(Int <span class="keyword">const</span>&amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> !(<span class="keyword">operator</span> &lt; (rhs) || <span class="keyword">operator</span> == (rhs));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> Int::<span class="keyword">operator</span> &gt;=(Int <span class="keyword">const</span>&amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> !(<span class="keyword">operator</span> &lt; (rhs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-3对象数组"><a href="#8-3对象数组" class="headerlink" title="8.3对象数组"></a>8.3对象数组</h3><p>顾名思义，就是存放类实例化数据的数组。会依次为每个对象调用构造函数，如果初始化列表的长度小于对象的数量，则任何剩余的对象都将由默认构造函数初始化（下例中s[2]就是由默认的构造函数构造的）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">int</span> x,y;</span><br><span class="line">		<span class="built_in">Point</span>(<span class="keyword">int</span> a = <span class="number">0</span>,<span class="keyword">int</span> b = <span class="number">0</span>):<span class="built_in">x</span>(a),<span class="built_in">y</span>(b)&#123;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;x = &quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot; y = &quot;</span>&lt;&lt;y&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Point s[<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">3</span>&#125;,&#123;<span class="number">2</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line">	s[<span class="number">0</span>].<span class="built_in">print</span>();<span class="comment">//x = 1 y = 3</span></span><br><span class="line">	s[<span class="number">1</span>].<span class="built_in">print</span>();<span class="comment">//x = 2 y = 7</span></span><br><span class="line">	s[<span class="number">2</span>].<span class="built_in">print</span>();<span class="comment">//x = 0 y = 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以显示调用构造函数并且使用缺省构造</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">int</span> x,y;</span><br><span class="line">		<span class="built_in">Point</span>(<span class="keyword">int</span> a = <span class="number">0</span>,<span class="keyword">int</span> b = <span class="number">0</span>):<span class="built_in">x</span>(a),<span class="built_in">y</span>(b)&#123;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;x = &quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot; y = &quot;</span>&lt;&lt;y&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	Point s[3] = &#123;&#123;1,3&#125;,&#123;2,7&#125;&#125;;</span></span><br><span class="line">	Point s[<span class="number">3</span>] = &#123;<span class="built_in">Point</span>(<span class="number">1</span>,<span class="number">3</span>),<span class="built_in">Point</span>(<span class="number">7</span>)&#125;;</span><br><span class="line">	s[<span class="number">0</span>].<span class="built_in">print</span>();<span class="comment">//x = 1 y = 3</span></span><br><span class="line">	s[<span class="number">1</span>].<span class="built_in">print</span>();<span class="comment">//x = 7 y = 0</span></span><br><span class="line">	s[<span class="number">2</span>].<span class="built_in">print</span>();<span class="comment">//x = 0 y = 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7大关键点（摘自C语言中文网）</p>
<ol>
<li>数组的元素可以是对象。</li>
<li>如果在创建对象数组时未使用初始化列表，则会为数组中的每个对象调用默认构造函数。</li>
<li>没有必要让数组中的所有对象都使用相同的构造函数。</li>
<li>如果在创建对象数组时使用初始化列表，则将根据所使用参数的数量和类型为每个对象用正确的构造函数。</li>
<li>如果构造函数需要多个参数，则初始化项必须釆用构造函数调用的形式。</li>
<li>如果列表中的初始化项调用少于数组中的对象，则将为所有剩余的对象调用默认构造函数。</li>
<li>最好总是提供一个默认的构造函数。如果没有，则必须确保为数组中的每个对象提供一个初始化项。</li>
</ol>
<h2 id="9">9. string、vector等基本容器类结合find、erase等基本算法的应用</h2>

<h3 id="9-1-string"><a href="#9-1-string" class="headerlink" title="9.1 string"></a>9.1 string</h3><blockquote>
<p>使用string相关内容，你需要包含string头文件</p>
</blockquote>
<p>string的特性：</p>
<ul>
<li>string直接支持字符串连接</li>
<li>string直接支持字符串的大小比较</li>
<li>string直接支持子串查找和提取</li>
<li>string直接支持字符串的插入和替换</li>
<li>string同时具备字符串数组的灵活性,可以通过[ ]重载操作符来访问每个字符。</li>
</ul>
<p>string类常用构造函数(摘自@诺谦)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string str;        <span class="comment">//生成一个空字符串</span></span><br><span class="line"><span class="function">string <span class="title">str</span> <span class="params">(<span class="string">&quot;ABC&quot;</span>)</span>  <span class="comment">//等价于 str=&quot;ABC&quot;&lt;br&gt;</span></span></span><br><span class="line"><span class="function">string <span class="title">str</span> <span class="params">(<span class="string">&quot;ABC&quot;</span>, strlen)</span>  <span class="comment">// 将&quot;ABC&quot;存到str里,最多存储前strlen个字节</span></span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;ABC&quot;</span>,stridx,strlen)</span>   <span class="comment">//将&quot;ABC&quot;的stridx位置,做为字符串开头,存到str里.且最多存储strlen个字节.</span></span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(strlen, <span class="string">&#x27;A&#x27;</span>)</span>  <span class="comment">//存储strlen个&#x27;A&#x27;到str里</span></span></span><br></pre></td></tr></table></figure>
<p>string类常用的成员函数有:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">str1.<span class="built_in">assign</span>(<span class="string">&quot;ABC&quot;</span>);　　　　　　　　<span class="comment">//清空string串,然后设置string串为&quot;ABC&quot;</span></span><br><span class="line">str1.<span class="built_in">length</span>()；                   <span class="comment">//获取字符串长度</span></span><br><span class="line">str1.<span class="built_in">size</span>();　　　　　　　　　　　 <span class="comment">//获取字符串数量,等价于length()</span></span><br><span class="line">str1.<span class="built_in">capacity</span>();　　　　　　　　  <span class="comment">//获取容量,容量包含了当前string里不必增加内存就能使用的字符数</span></span><br><span class="line">str1.<span class="built_in">resize</span>(<span class="number">10</span>);　　　　　　      <span class="comment">//表示设置当前string里的串大小,若设置大小大于当前串长度,则用字符\0来填充多余的.</span></span><br><span class="line">str1.<span class="built_in">resize</span>(<span class="number">10</span>,<span class="keyword">char</span> c);　　　　   <span class="comment">//设置串大小，若设置大小大于当前串长度,则用字符c来填充多余的</span></span><br><span class="line">str1.<span class="built_in">reserve</span>(<span class="number">10</span>);　　　　　　　　　<span class="comment">//设置string里的串容量,不会填充数据.</span></span><br><span class="line">str1.<span class="built_in">swap</span>(str2);        　　      <span class="comment">//替换str1 和 str2 的字符串</span></span><br><span class="line">str1.<span class="built_in">puch_back</span> (<span class="string">&#x27;A&#x27;</span>);    　　     <span class="comment">//在str1末尾添加一个&#x27;A&#x27;字符,参数必须是字符形式</span></span><br><span class="line">str1.<span class="built_in">append</span> (<span class="string">&quot;ABC&quot;</span>);     　　     <span class="comment">//在str1末尾添加一个&quot;ABC&quot;字符串,参数必须是字符串形式</span></span><br><span class="line">str1.<span class="built_in">insert</span> (<span class="number">2</span>,<span class="string">&quot;ABC&quot;</span>);           <span class="comment">//在str1的下标为2的位置,插入&quot;ABC&quot;</span></span><br><span class="line">str1.<span class="built_in">erase</span>(<span class="number">2</span>);         　　　　  <span class="comment">//删除下标为2的位置,比如: &quot;ABCD&quot; --&gt; &quot;AB&quot;</span></span><br><span class="line">str1.<span class="built_in">erase</span>(<span class="number">2</span>,<span class="number">1</span>);                <span class="comment">//从下标为2的位置删除1个,比如: &quot;ABCD&quot;  --&gt; &quot;ABD&quot;</span></span><br><span class="line">str1.<span class="built_in">clear</span>();           　　    <span class="comment">//删除所有</span></span><br><span class="line">str1.<span class="built_in">replace</span>(<span class="number">2</span>,<span class="number">4</span>, <span class="string">&quot;ABCD&quot;</span>);     <span class="comment">//从下标为2的位置,替换4个字节,为&quot;ABCD&quot;</span></span><br><span class="line">str1.<span class="built_in">empty</span>();         　　     <span class="comment">//判断为空, 为空返回true</span></span><br></pre></td></tr></table></figure>
<p>关于assign</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*assign() :赋值函数 ,里面会重新释放分配字符串内存 */</span></span><br><span class="line">str1.<span class="built_in">assign</span>(<span class="string">&quot;HELLO&quot;</span>);                   <span class="comment">//str1=&quot;HELLO&quot;</span></span><br><span class="line">str1.<span class="built_in">assign</span>(<span class="string">&quot;HELLO&quot;</span>, <span class="number">4</span>);                <span class="comment">//str1=&quot;HELL&quot; ,只保留4个字符</span></span><br><span class="line">str1.<span class="built_in">assign</span>(<span class="string">&quot;HELLO&quot;</span>, <span class="number">2</span>, <span class="number">3</span>);             <span class="comment">//str1=&quot;LLO&quot;    ,从位置2开始,只保留3个字符</span></span><br><span class="line">str1.<span class="built_in">assign</span>(<span class="number">5</span>, <span class="string">&#x27;c&#x27;</span>);                    <span class="comment">//str1=&quot;CCCCC&quot;             //按字符赋值</span></span><br></pre></td></tr></table></figure>

<p>字符串的反转需要包含algorithm头文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	string str_1 = <span class="string">&quot;1145141919810&quot;</span>;</span><br><span class="line">	<span class="built_in">reverse</span>(str_1.<span class="built_in">begin</span>(),str_1.<span class="built_in">end</span>());</span><br><span class="line">	cout&lt;&lt;str_1&lt;&lt;endl;<span class="comment">//0189191415411</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入的参数是一个迭代器变量</p>
<p>如果期望查找其中的子串，则需要使用find方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	string str_1 = <span class="string">&quot;1145141919810&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> n = str_1.<span class="built_in">find</span>(<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">	<span class="keyword">int</span> s = str_1.<span class="built_in">find</span>(<span class="string">&quot;419&quot;</span>);</span><br><span class="line">	cout&lt;&lt;n&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;s&lt;&lt;endl;<span class="comment">//7 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有必要注意的是，第一个查找传入的应当是’9’或者”9”而不是int类型的数字9。</p>
<p>查到子串后返回子串首字符在字符串中的下标，请注意，下标是<b>从零开始</b>计数的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//详细用法</span></span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;ABCDEFGABCD&quot;</span>)</span></span>; </span><br><span class="line">n= str.<span class="built_in">find</span>(<span class="string">&quot;BC&quot;</span>,<span class="number">1</span>);           <span class="comment">//从位置1处,查找&quot;BC&quot;,n=1;</span></span><br><span class="line">n= str.<span class="built_in">find</span>(<span class="string">&quot;CDEfg&quot;</span>,<span class="number">1</span>,<span class="number">3</span>);      <span class="comment">//从位置1处,查找&quot;CDEfg&quot;的前3个字符,等价于str.find(&quot;CDE&quot;,1),n=2;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*rfind():反向(reverse)查找,从末尾处开始,向前查找*/</span></span><br><span class="line">n= str.<span class="built_in">rfind</span>(<span class="string">&quot;CD&quot;</span>);           <span class="comment">//从位置10开始向前查找,n=9</span></span><br><span class="line">n= str.<span class="built_in">rfind</span>(<span class="string">&quot;CD&quot;</span>,<span class="number">5</span>);         <span class="comment">//从位置5开始向前查找,n=2</span></span><br><span class="line">n= str.<span class="built_in">rfind</span>(<span class="string">&quot;CDEfg&quot;</span>,<span class="number">5</span>,<span class="number">3</span>);    <span class="comment">//等价于str.rfind(&quot;CDE&quot;,5);       ,所以n=2</span></span><br></pre></td></tr></table></figure>
<p>拷贝相关:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str2=str1.<span class="built_in">substr</span>(<span class="number">2</span>);        <span class="comment">//提取子串,提取出str1的下标为2到末尾,给str2</span></span><br><span class="line">str2=str1.<span class="built_in">substr</span>(<span class="number">2</span>,<span class="number">3</span>);     <span class="comment">//提取子串,从 str1的下标为2开始,提取3个字节给str2</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *s1= str.<span class="built_in">data</span>();   <span class="comment">//将string类转为字符串数组,返回给s1</span></span><br><span class="line"><span class="keyword">char</span> *s=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line">str.<span class="built_in">copy</span>(s,count,pos);    <span class="comment">//将str里的pos位置开始,拷贝count个字符,存到s里.</span></span><br></pre></td></tr></table></figure>

<h3 id="9-2-vector"><a href="#9-2-vector" class="headerlink" title="9.2 vector"></a>9.2 vector</h3><blockquote>
<p>使用vector容器，你需要包含vector头文件</p>
</blockquote>
<p>容器的创建：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="comment">//创建一个名字叫a的vector容器，装的是int类型数据，大小是10，每个容器的值都是1</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="comment">//也可以这样，只指定大小不设初值</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(b)</span></span>;</span><br><span class="line"><span class="comment">//也可以基于另一个vector&lt;int&gt;来创建新的vector&lt;int&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于一个vector&lt;int&gt; a，常用的操作有：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a[i]; <span class="comment">//返回a的第i个元素，当且仅当a[i]存在</span></span><br><span class="line">a.<span class="built_in">back</span>(); <span class="comment">//返回a的最后一个元素</span></span><br><span class="line">a.<span class="built_in">front</span>(); <span class="comment">//返回a的第一个元素</span></span><br><span class="line">a.<span class="built_in">clear</span>(); <span class="comment">//清空a中的元素</span></span><br><span class="line">a.<span class="built_in">empty</span>(); <span class="comment">//判断a是否为空，空则返回ture,不空则返回false</span></span><br><span class="line">a.<span class="built_in">size</span>(); <span class="comment">//返回a中元素的个数；</span></span><br><span class="line">a.<span class="built_in">push_back</span>(<span class="number">5</span>); <span class="comment">//在a的最后一个向量后插入一个元素，其值为5</span></span><br><span class="line">a.<span class="built_in">pop_back</span>(); <span class="comment">//删除a向量的最后一个元素</span></span><br><span class="line">a.<span class="built_in">resize</span>(<span class="number">10</span>); <span class="comment">//将a的现有元素个数调至10个，多则删，少则补，其值随机</span></span><br><span class="line">a.<span class="built_in">resize</span>(<span class="number">10</span>,<span class="number">2</span>); <span class="comment">//将a的现有元素个数调至10个，多则删，少则补，其值为2</span></span><br></pre></td></tr></table></figure>
<p>对于该容器的遍历：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;a;</span><br><span class="line">	a.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	a.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	<span class="keyword">for</span>(vector&lt;<span class="keyword">int</span>&gt;::iterator it=a.<span class="built_in">begin</span>();it&lt;a.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">		cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用vector&lt;int&gt;::iterator定义一个vector&lt;int&gt;类型的迭代器变量it。it支持自加和自减操作，相当于访问后一个或者前一个元素。</p>
<p>vector的earse操作，传入的参数是一个迭代器，删除迭代器指向的元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;a;</span><br><span class="line">	a.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	a.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	a.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line">	a.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	a.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">	<span class="keyword">for</span>(vector&lt;<span class="keyword">int</span>&gt;::iterator it=a.<span class="built_in">begin</span>();it&lt;a.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">		cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::iterator it=a.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">for</span>(;it&lt;a.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(*it == <span class="number">3</span>)&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	a.<span class="built_in">erase</span>(it);</span><br><span class="line">	cout&lt;&lt;*it&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span>(vector&lt;<span class="keyword">int</span>&gt;::iterator it=a.<span class="built_in">begin</span>();it&lt;a.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">		cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出：<br>1 4 6 3 7<br>7<br>1 4 6 7</p>
</blockquote>
<p>所以不难看出erase的用法是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型：</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(iterator position)</span></span>;	<span class="comment">//删除指定元素</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(iterator first, iterator last)</span></span>;	<span class="comment">//删除指定范围内的元素</span></span><br><span class="line"><span class="comment">//返回值：指向删除元素(或范围)的下一个元素。</span></span><br></pre></td></tr></table></figure>
<p><b>误区：</b></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误示例</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    a[i]=i;</span><br></pre></td></tr></table></figure>

<p>下标访问仅可以访问和修改已有元素，在未初始化时，使用下标访问是错误的。</p>
<p>常用算法：</p>
<p>在#include&lt;algorithm&gt;后，你可以使用几个常用的算法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>()); <span class="comment">//对a中的从a.begin()（包括它）到a.end()（不包括它）的元素进行从小到大排列</span></span><br><span class="line"><span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>()); <span class="comment">//对a中的从a.begin()（包括它）到a.end()（不包括它）的元素倒置，但不排列，如a中元素为1,3,2,4,倒置后为4,2,3,1</span></span><br><span class="line"><span class="built_in">copy</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),b.<span class="built_in">begin</span>()+<span class="number">1</span>); <span class="comment">//把a中的从a.begin()（包括它）到a.end()（不包括它）的元素复制到b中，从b.begin()+1的位置（包括它）开        始复制，覆盖掉原有元素</span></span><br><span class="line"><span class="built_in">find</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),<span class="number">10</span>); <span class="comment">//在a中的从a.begin()（包括它）到a.end()（不包括它）的元素中查找10，若存在返回其在向量中的位置</span></span><br></pre></td></tr></table></figure>

<p>请注意，这不是类对象的方法，不要使用a.sort()这种形式调用它。</p>
<h2 id="10">10. 类及常用成员函数的定义，类的复合关系的应用</h2>

<p>在 C++ 中，类和类之间有两种基本关系：复合关系和继承关系。</p>
<p>复合关系也称为“has-a”关系或“有”的关系,即一个类以另一个类的对象作为成员变量。</p>
<p>这里就有了封闭类的定义：一个类的成员变量如果是另一个类的对象，就称之为“成员对象”。包含成员对象的类叫封闭类（enclosed class）。</p>
<p>下例中Line是封闭类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">int</span> x,y;</span><br><span class="line">		<span class="built_in">Point</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b):<span class="built_in">x</span>(a),<span class="built_in">y</span>(b)&#123;&#125;</span><br><span class="line">		<span class="built_in">Point</span>(Point&amp; c)&#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;x = c.x;</span><br><span class="line">			<span class="keyword">this</span>-&gt;y = c.y;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;Point: x= &quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot; y= &quot;</span>&lt;&lt;y&lt;&lt;endl;</span><br><span class="line">		&#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		Point l,r;<span class="comment">//线的左右端点</span></span><br><span class="line">		<span class="keyword">int</span> length;</span><br><span class="line">		<span class="built_in">Line</span>(Point a,Point b):<span class="built_in">l</span>(a),<span class="built_in">r</span>(b)&#123;</span><br><span class="line">			length = <span class="built_in">sqrt</span>((l.x-r.x)*(l.x-r.x)+(l.y-r.y)*(l.y-r.y));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;Line length = &quot;</span>&lt;&lt;length&lt;&lt;endl;</span><br><span class="line">		&#125;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		Point lu,rd;<span class="comment">//使用左上角和右下角可以定义一个长方形 </span></span><br><span class="line">		<span class="built_in">Rectangle</span>(Point a,Point b):<span class="built_in">lu</span>(a),<span class="built_in">rd</span>(b)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">0</span>,<span class="number">3</span>)</span>,<span class="title">p2</span><span class="params">(<span class="number">4</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function">Line <span class="title">l1</span><span class="params">(p1,p2)</span></span>;</span><br><span class="line">	cout&lt;&lt;l1.length&lt;&lt;endl;<span class="comment">//输出5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写封闭类时，注意包含的那个类成员的可访问性，如果将数据设为private，则可能需要额外设置get、set函数来读写相关值。</p>
<h2 id="11">11. 多态性的应用，要求用类图分析类及继承关系，要求抽象基类、动态多态性</h2>

<blockquote>
<p>面向对象三大特性是”封装、”多态”、”继承”</p>
</blockquote>
<p>在C++程序设计中，多态性是指用一个名字定义不同的函数，这些函数执行不同但又类似的操作，这样就可以用同一个函数名调用不同内容的函数。换言之，可以用同样的接口访问功能不同的函数，从而实现“一个接口，多种方法”。</p>
<p>在C++中，多态性的实现和联编（也称绑定）这一概念有关。一个源程序经过编译、链接，成为可执行文件的过程是把可执行代码联编（或称装配）在一起的过程。其中在运行之前就完成的联编成为静态联编（前期联编）；而在程序运行之时才完成的联编叫动态联编（后期联编）。</p>
<p>静态联编支持的多态性称为编译时多态性（静态多态性）。在C++中，编译时多态性是通过函数重载和模板实现的。利用函数重载机制，在调用同名函数时，编译系统会根据实参的具体情况确定索要调用的是哪个函数。</p>
<p>动态联编所支持的多态性称为运行时多态（动态多态）。在C++中，运行时多态性是通过虚函数来实现的。</p>
<p><b>如果不实现多态，不要把函数定义成虚函数。</b></p>
<p>对于纯虚函数，子类必须提供纯虚函数的个性化实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span>&#123;</span></span><br><span class="line">	<span class="comment">//车抽象类 </span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">int</span> wheel;<span class="comment">//轮子数</span></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">printwheel</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>:</span><span class="keyword">virtual</span> Vehicle&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Car</span>(<span class="keyword">int</span> a)&#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;wheel = a;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">printwheel</span><span class="params">()</span></span>&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;the car has &quot;</span>&lt;&lt;wheel&lt;&lt;<span class="string">&quot; wheel(s)&quot;</span>&lt;&lt;endl; </span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bike</span>:</span><span class="keyword">virtual</span> Vehicle&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Bike</span>(<span class="keyword">int</span> a)&#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;wheel = a;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">printwheel</span><span class="params">()</span></span>&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;the bike has &quot;</span>&lt;&lt;wheel&lt;&lt;<span class="string">&quot; wheel(s)&quot;</span>&lt;&lt;endl; </span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Vehicle* p = <span class="keyword">new</span> <span class="built_in">Car</span>(<span class="number">6</span>);</span><br><span class="line">	p-&gt;<span class="built_in">printwheel</span>();<span class="comment">//the car has 6 wheel(s)</span></span><br><span class="line">	<span class="function">Bike <span class="title">b</span><span class="params">(<span class="number">2</span>)</span> </span>;</span><br><span class="line">	b.<span class="built_in">printwheel</span>();<span class="comment">//the bike has 2 wheel(s)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序Bike和Car继承自虚基类Vehicle，重写了输出轮子树目的方法。</p>
<p>类图的学习参阅此博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zhanghuaichao/article/details/52964463">https://blog.csdn.net/zhanghuaichao/article/details/52964463</a></p>
<p>markdown画图麻烦，不画了。</p>
<h2 id="12">12. 个人见到的一些琐碎知识点</h2>

<h3 id="12-1-友元"><a href="#12-1-友元" class="headerlink" title="12.1 友元"></a>12.1 友元</h3><p>友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。</p>
<p>类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。</p>
<p><b>友元函数没有this指针</b></p>
<p>友元的目的：<b>让一个类或函数去访问另一个类中的私有成员</b>，注意啊，不是互相访问。</p>
<h4 id="12-1-1-友元与运算符重载"><a href="#12-1-1-友元与运算符重载" class="headerlink" title="12.1.1 友元与运算符重载"></a>12.1.1 友元与运算符重载</h4><p>当重载友元函数时，将没有隐含的参数this指针。</p>
<p>对于双目运算符，友元函数有2个参数，对于单目运算符，友元函数有一个参数。但是，有些运行符不能重载为友元函数，它们是：=,(),[]和-＞。</p>
<p>对于&lt;&lt;和&gt;&gt;，我们需要把运算符重载函数声明为类的友元函数，这样我们就能不用创建对象而直接调用函数。</p>
<h4 id="12-1-2-多说两句运算符重载"><a href="#12-1-2-多说两句运算符重载" class="headerlink" title="12.1.2 多说两句运算符重载"></a>12.1.2 多说两句运算符重载</h4><p>单目运算符最好被重载为成员，双目运算符最好被重载为友元函数。但是，有的双目运算符还是重载为成员函数为好，例如，赋值运算符。因为，它如果被重载为友元函数，将会出现与赋值语义不一致的地方。 </p>
<p><b>重载函数调用运算符</b></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> ＜iostream.h＞</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">F::operator</span> <span class="params">()</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (x+<span class="number">5</span>)*y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	F f;</span><br><span class="line">	cout＜＜<span class="built_in">f</span>(<span class="number">1.5</span>, <span class="number">2.2</span>)＜＜endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-2-put函数"><a href="#12-2-put函数" class="headerlink" title="12.2 put函数"></a>12.2 put函数</h3><blockquote>
<p>要使用这个函数，你需要#include&lt;iostream&gt;</p>
</blockquote>
<p>C++的ostream类有专用于输出单个字符的成员函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出字符a的示例</span></span><br><span class="line">cout.<span class="built_in">put</span>(‘a’);</span><br><span class="line">cout.<span class="built_in">put</span>(<span class="number">65</span> + <span class="number">32</span>);</span><br></pre></td></tr></table></figure>

<p>同时，也可以输出转义字符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout.<span class="built_in">put</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>这已经可以输出了，因此下例是画蛇添足的行为，非常错误。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;<span class="built_in">put</span>(<span class="string">&#x27;A&#x27;</span>);<span class="comment">//错误示例</span></span><br></pre></td></tr></table></figure>
<h3 id="12-3-ASCII码"><a href="#12-3-ASCII码" class="headerlink" title="12.3 ASCII码"></a>12.3 ASCII码</h3><p>A是65，a是97</p>
<h3 id="12-4"><a href="#12-4" class="headerlink" title="12.4"></a>12.4</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://nszjjj.github.io/2021/12/20/NoteofCpp/" data-id="ckxfhqdh600016sui1lmnbrhy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2021/12/20/test-my-site/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">test_my_site</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/12/20/NoteofCpp/">李二狗的C++备考笔记</a>
          </li>
        
          <li>
            <a href="/2021/12/20/test-my-site/">test_my_site</a>
          </li>
        
          <li>
            <a href="/2021/12/20/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 nszjjj<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>